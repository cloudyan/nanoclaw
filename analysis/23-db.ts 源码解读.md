# src/db.ts 源码解读

## 概述

`src/db.ts` 是 NanoClaw 的数据持久化层，使用 SQLite 数据库存储聊天元数据、消息历史和定时任务。该模块提供了完整的 CRUD 操作，并针对查询性能进行了索引优化。

**文件路径**: `src/db.ts` (285 行)

**核心功能**:
- 数据库初始化和表结构管理
- 聊天元数据存储（不包含敏感消息内容）
- 消息历史存储和查询
- 定时任务的创建、调度和执行日志

---

## 数据库表结构

### 1. chats 表

**用途**: 存储所有聊天的元数据，用于群组发现，不存储敏感消息内容。

**字段说明**:
| 字段 | 类型 | 说明 |
|------|------|------|
| jid | TEXT (PRIMARY KEY) | 聊天唯一标识符 |
| name | TEXT | 聊天名称（群组名或联系人名） |
| last_message_time | TEXT | 最后一条消息的时间戳（ISO 8601 格式） |

**特殊用途**: 使用 `__group_sync__` 作为特殊 jid 存储群组元数据同步时间。

---

### 2. messages 表

**用途**: 存储已注册群组的完整消息历史，用于上下文恢复。

**字段说明**:
| 字段 | 类型 | 说明 |
|------|------|------|
| id | TEXT | 消息 ID |
| chat_jid | TEXT | 所属聊天的 jid |
| sender | TEXT | 发送者 jid |
| sender_name | TEXT | 发送者显示名称 |
| content | TEXT | 消息内容（文本或图片/视频的 caption） |
| timestamp | TEXT | 消息时间戳（ISO 8601 格式） |
| is_from_me | INTEGER | 是否为本人发送（0 或 1） |

**主键**: `(id, chat_jid)` 复合主键

**外键**: `chat_jid` 引用 `chats(jid)`

**索引**: `idx_timestamp` - 优化按时间戳查询

---

### 3. scheduled_tasks 表

**用途**: 存储定时任务配置，支持多种调度类型（cron、interval 等）。

**字段说明**:
| 字段 | 类型 | 说明 |
|------|------|------|
| id | TEXT (PRIMARY KEY) | 任务唯一标识符 |
| group_folder | TEXT | 所属群组的文件夹名称 |
| chat_jid | TEXT | 目标聊天 jid |
| prompt | TEXT | 任务提示词 |
| schedule_type | TEXT | 调度类型（如 'cron', 'interval'） |
| schedule_value | TEXT | 调度值（如 cron 表达式或间隔秒数） |
| next_run | TEXT | 下次执行时间（ISO 8601 格式） |
| last_run | TEXT | 上次执行时间 |
| last_result | TEXT | 上次执行结果 |
| status | TEXT | 任务状态（'active', 'paused', 'completed'） |
| created_at | TEXT | 任务创建时间 |
| context_mode | TEXT | 上下文模式（'isolated' 或 'shared'） |

**索引**:
- `idx_next_run` - 优化查询到期任务
- `idx_status` - 优化按状态筛选任务

---

### 4. task_run_logs 表

**用途**: 记录每次任务执行的详细日志，用于调试和审计。

**字段说明**:
| 字段 | 类型 | 说明 |
|------|------|------|
| id | INTEGER (PRIMARY KEY AUTOINCREMENT) | 日志 ID（自增） |
| task_id | TEXT | 关联的任务 ID |
| run_at | TEXT | 执行时间（ISO 8601 格式） |
| duration_ms | INTEGER | 执行耗时（毫秒） |
| status | TEXT | 执行状态（'success', 'error'） |
| result | TEXT | 执行结果摘要 |
| error | TEXT | 错误信息（如果失败） |

**外键**: `task_id` 引用 `scheduled_tasks(id)`

**索引**: `idx_task_run_logs` - 复合索引 `(task_id, run_at)`，优化按任务查询执行历史

---

## 核心函数详解

### 1. initDatabase()

**文件路径**: `src/db.ts:10-72`

**功能**: 初始化数据库连接，创建表结构和索引，处理数据库迁移。

```typescript
export function initDatabase(): void {
  const dbPath = path.join(STORE_DIR, 'messages.db');
  fs.mkdirSync(path.dirname(dbPath), { recursive: true });

  db = new Database(dbPath);
  db.exec(`
    CREATE TABLE IF NOT EXISTS chats (...);
    CREATE TABLE IF NOT EXISTS messages (...);
    CREATE INDEX IF NOT EXISTS idx_timestamp ON messages(timestamp);
    CREATE TABLE IF NOT EXISTS scheduled_tasks (...);
    CREATE INDEX IF NOT EXISTS idx_next_run ON scheduled_tasks(next_run);
    CREATE INDEX IF NOT EXISTS idx_status ON scheduled_tasks(status);
    CREATE TABLE IF NOT EXISTS task_run_logs (...);
    CREATE INDEX IF NOT EXISTS idx_task_run_logs ON task_run_logs(task_id, run_at);
  `);

  // 迁移：添加 sender_name 列
  try {
    db.exec(`ALTER TABLE messages ADD COLUMN sender_name TEXT`);
  } catch { /* column already exists */ }

  // 迁移：添加 context_mode 列
  try {
    db.exec(`ALTER TABLE scheduled_tasks ADD COLUMN context_mode TEXT DEFAULT 'isolated'`);
  } catch { /* column already exists */ }
}
```

**关键点**:
- 使用 `CREATE TABLE IF NOT EXISTS` 确保幂等性
- 使用 `CREATE INDEX IF NOT EXISTS` 避免重复创建索引
- 通过 `try-catch` 实现渐进式数据库迁移，兼容旧版本数据库

---

### 2. storeChatMetadata()

**文件路径**: `src/db.ts:78-95`

**功能**: 存储聊天元数据（不包含消息内容），用于所有聊天以启用群组发现。

```typescript
export function storeChatMetadata(chatJid: string, timestamp: string, name?: string): void {
  if (name) {
    // 更新名称，保留较新的时间戳
    db.prepare(`
      INSERT INTO chats (jid, name, last_message_time) VALUES (?, ?, ?)
      ON CONFLICT(jid) DO UPDATE SET
        name = excluded.name,
        last_message_time = MAX(last_message_time, excluded.last_message_time)
    `).run(chatJid, name, timestamp);
  } else {
    // 仅更新时间戳，保留现有名称
    db.prepare(`
      INSERT INTO chats (jid, name, last_message_time) VALUES (?, ?, ?)
      ON CONFLICT(jid) DO UPDATE SET
        last_message_time = MAX(last_message_time, excluded.last_message_time)
    `).run(chatJid, chatJid, timestamp);
  }
}
```

**关键点**:
- 使用 `ON CONFLICT(jid) DO UPDATE` 实现 upsert 语义
- 使用 `MAX()` 函数确保时间戳始终为最新值
- 当没有名称时，使用 jid 作为占位符

---

### 3. updateChatName()

**文件路径**: `src/db.ts:102-107`

**功能**: 更新聊天名称而不改变现有聊天的时间戳，用于群组元数据同步。

```typescript
export function updateChatName(chatJid: string, name: string): void {
  db.prepare(`
    INSERT INTO chats (jid, name, last_message_time) VALUES (?, ?, ?)
    ON CONFLICT(jid) DO UPDATE SET name = excluded.name
  `).run(chatJid, name, new Date().toISOString());
}
```

**关键点**:
- 新聊天使用当前时间作为初始时间戳
- 现有聊天仅更新名称，保留原有时间戳

---

### 4. getAllChats()

**文件路径**: `src/db.ts:118-124`

**功能**: 获取所有已知聊天，按最近活动时间排序。

```typescript
export function getAllChats(): ChatInfo[] {
  return db.prepare(`
    SELECT jid, name, last_message_time
    FROM chats
    ORDER BY last_message_time DESC
  `).all() as ChatInfo[];
}
```

**关键点**:
- 返回按活动时间倒序排列的聊天列表
- 用于主频道显示所有可用群组

---

### 5. storeMessage()

**文件路径**: `src/db.ts:147-164`

**功能**: 存储完整消息内容，仅对已注册群组调用。

```typescript
export function storeMessage(msg: proto.IWebMessageInfo, chatJid: string, isFromMe: boolean, pushName?: string): void {
  if (!msg.key) return;

  const content =
    msg.message?.conversation ||
    msg.message?.extendedTextMessage?.text ||
    msg.message?.imageMessage?.caption ||
    msg.message?.videoMessage?.caption ||
    '';

  const timestamp = new Date(Number(msg.messageTimestamp) * 1000).toISOString();
  const sender = msg.key.participant || msg.key.remoteJid || '';
  const senderName = pushName || sender.split('@')[0];
  const msgId = msg.key.id || '';

  db.prepare(`INSERT OR REPLACE INTO messages (id, chat_jid, sender, sender_name, content, timestamp, is_from_me) VALUES (?, ?, ?, ?, ?, ?, ?)`)
    .run(msgId, chatJid, sender, senderName, content, timestamp, isFromMe ? 1 : 0);
}
```

**关键点**:
- 提取多种消息类型的内容（文本、图片 caption、视频 caption）
- 将 Unix 时间戳转换为 ISO 8601 格式
- 使用 `INSERT OR REPLACE` 处理重复消息
- 发送者名称优先使用 pushName，否则使用 jid 的用户名部分

---

### 6. getNewMessages()

**文件路径**: `src/db.ts:166-186`

**功能**: 获取指定聊天列表中的新消息，过滤机器人自己的消息。

```typescript
export function getNewMessages(jids: string[], lastTimestamp: string, botPrefix: string): { messages: NewMessage[]; newTimestamp: string } {
  if (jids.length === 0) return { messages: [], newTimestamp: lastTimestamp };

  const placeholders = jids.map(() => '?').join(',');
  // 通过内容前缀过滤机器人消息（而非 is_from_me，因为用户共享账户）
  const sql = `
    SELECT id, chat_jid, sender, sender_name, content, timestamp
    FROM messages
    WHERE timestamp > ? AND chat_jid IN (${placeholders}) AND content NOT LIKE ?
    ORDER BY timestamp
  `;

  const rows = db.prepare(sql).all(lastTimestamp, ...jids, `${botPrefix}:%`) as NewMessage[];

  let newTimestamp = lastTimestamp;
  for (const row of rows) {
    if (row.timestamp > newTimestamp) newTimestamp = row.timestamp;
  }

  return { messages: rows, newTimestamp };
}
```

**关键点**:
- 使用动态占位符支持可变数量的 jid
- 通过 `content NOT LIKE ?` 过滤机器人消息（因为用户和机器人共享 WhatsApp 账户）
- 返回最新的时间戳用于下次轮询
- 利用 `idx_timestamp` 索引优化时间范围查询

---

### 7. getMessagesSince()

**文件路径**: `src/db.ts:188-197`

**功能**: 获取指定聊天自某个时间点以来的所有消息。

```typescript
export function getMessagesSince(chatJid: string, sinceTimestamp: string, botPrefix: string): NewMessage[] {
  const sql = `
    SELECT id, chat_jid, sender, sender_name, content, timestamp
    FROM messages
    WHERE chat_jid = ? AND timestamp > ? AND content NOT LIKE ?
    ORDER BY timestamp
  `;
  return db.prepare(sql).all(chatJid, sinceTimestamp, `${botPrefix}:%`) as NewMessage[];
}
```

**关键点**:
- 用于恢复特定聊天的上下文
- 同样过滤机器人消息

---

### 8. createTask()

**文件路径**: `src/db.ts:199-215`

**功能**: 创建新的定时任务。

```typescript
export function createTask(task: Omit<ScheduledTask, 'last_run' | 'last_result'>): void {
  db.prepare(`
    INSERT INTO scheduled_tasks (id, group_folder, chat_jid, prompt, schedule_type, schedule_value, context_mode, next_run, status, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    task.id,
    task.group_folder,
    task.chat_jid,
    task.prompt,
    task.schedule_type,
    task.schedule_value,
    task.context_mode || 'isolated',
    task.next_run,
    task.status,
    task.created_at
  );
}
```

**关键点**:
- 使用 TypeScript 的 `Omit` 类型排除运行时字段（last_run, last_result）
- context_mode 默认值为 'isolated'

---

### 9. getTaskById()

**文件路径**: `src/db.ts:217-219`

**功能**: 根据 ID 获取单个任务。

```typescript
export function getTaskById(id: string): ScheduledTask | undefined {
  return db.prepare('SELECT * FROM scheduled_tasks WHERE id = ?').get(id) as ScheduledTask | undefined;
}
```

---

### 10. getTasksForGroup()

**文件路径**: `src/db.ts:221-223`

**功能**: 获取指定群组的所有任务，按创建时间倒序排列。

```typescript
export function getTasksForGroup(groupFolder: string): ScheduledTask[] {
  return db.prepare('SELECT * FROM scheduled_tasks WHERE group_folder = ? ORDER BY created_at DESC').all(groupFolder) as ScheduledTask[];
}
```

---

### 11. getAllTasks()

**文件路径**: `src/db.ts:225-227`

**功能**: 获取所有任务，按创建时间倒序排列。

```typescript
export function getAllTasks(): ScheduledTask[] {
  return db.prepare('SELECT * FROM scheduled_tasks ORDER BY created_at DESC').all() as ScheduledTask[];
}
```

---

### 12. updateTask()

**文件路径**: `src/db.ts:229-243`

**功能**: 更新任务的指定字段。

```typescript
export function updateTask(id: string, updates: Partial<Pick<ScheduledTask, 'prompt' | 'schedule_type' | 'schedule_value' | 'next_run' | 'status'>>): void {
  const fields: string[] = [];
  const values: unknown[] = [];

  if (updates.prompt !== undefined) { fields.push('prompt = ?'); values.push(updates.prompt); }
  if (updates.schedule_type !== undefined) { fields.push('schedule_type = ?'); values.push(updates.schedule_type); }
  if (updates.schedule_value !== undefined) { fields.push('schedule_value = ?'); values.push(updates.schedule_value); }
  if (updates.next_run !== undefined) { fields.push('next_run = ?'); values.push(updates.next_run); }
  if (updates.status !== undefined) { fields.push('status = ?'); values.push(updates.status); }

  if (fields.length === 0) return;

  values.push(id);
  db.prepare(`UPDATE scheduled_tasks SET ${fields.join(', ')} WHERE id = ?`).run(...values);
}
```

**关键点**:
- 动态构建 SQL UPDATE 语句，仅更新提供的字段
- 使用 TypeScript 的 `Partial<Pick<...>>` 类型确保类型安全

---

### 13. deleteTask()

**文件路径**: `src/db.ts:245-249`

**功能**: 删除任务及其执行日志。

```typescript
export function deleteTask(id: string): void {
  // 先删除子记录（外键约束）
  db.prepare('DELETE FROM task_run_logs WHERE task_id = ?').run(id);
  db.prepare('DELETE FROM scheduled_tasks WHERE id = ?').run(id);
}
```

**关键点**:
- 必须先删除子记录（task_run_logs），否则会违反外键约束

---

### 14. getDueTasks()

**文件路径**: `src/db.ts:251-258`

**功能**: 获取所有到期的活跃任务，按执行时间排序。

```typescript
export function getDueTasks(): ScheduledTask[] {
  const now = new Date().toISOString();
  return db.prepare(`
    SELECT * FROM scheduled_tasks
    WHERE status = 'active' AND next_run IS NOT NULL AND next_run <= ?
    ORDER BY next_run
  `).all(now) as ScheduledTask[];
}
```

**关键点**:
- 利用 `idx_next_run` 索引优化查询性能
- 利用 `idx_status` 索引优化状态筛选
- 返回按执行时间排序的任务列表

---

### 15. updateTaskAfterRun()

**文件路径**: `src/db.ts:260-267`

**功能**: 更新任务执行后的状态，包括下次执行时间和执行结果。

```typescript
export function updateTaskAfterRun(id: string, nextRun: string | null, lastResult: string): void {
  const now = new Date().toISOString();
  db.prepare(`
    UPDATE scheduled_tasks
    SET next_run = ?, last_run = ?, last_result = ?, status = CASE WHEN ? IS NULL THEN 'completed' ELSE status END
    WHERE id = ?
  `).run(nextRun, now, lastResult, nextRun, id);
}
```

**关键点**:
- 使用 `CASE WHEN` 表达式：如果 nextRun 为 null，则将状态设置为 'completed'
- 同时更新 last_run 和 last_result

---

### 16. logTaskRun()

**文件路径**: `src/db.ts:269-274`

**功能**: 记录任务执行的详细日志。

```typescript
export function logTaskRun(log: TaskRunLog): void {
  db.prepare(`
    INSERT INTO task_run_logs (task_id, run_at, duration_ms, status, result, error)
    VALUES (?, ?, ?, ?, ?, ?)
  `).run(log.task_id, log.run_at, log.duration_ms, log.status, log.result, log.error);
}
```

**关键点**:
- 记录执行耗时、状态、结果和错误信息
- 用于调试和审计

---

### 17. getTaskRunLogs()

**文件路径**: `src/db.ts:276-284`

**功能**: 获取指定任务的执行日志，默认返回最近 10 条。

```typescript
export function getTaskRunLogs(taskId: string, limit = 10): TaskRunLog[] {
  return db.prepare(`
    SELECT task_id, run_at, duration_ms, status, result, error
    FROM task_run_logs
    WHERE task_id = ?
    ORDER BY run_at DESC
    LIMIT ?
  `).all(taskId, limit) as TaskRunLog[];
}
```

**关键点**:
- 利用 `idx_task_run_logs` 复合索引优化查询
- 返回按执行时间倒序排列的日志

---

## 索引优化策略

### 1. idx_timestamp (messages 表)

```sql
CREATE INDEX IF NOT EXISTS idx_timestamp ON messages(timestamp);
```

**优化场景**:
- `getNewMessages()` - 按时间范围查询新消息
- `getMessagesSince()` - 查询指定时间点之后的消息

**性能提升**: 避免全表扫描，快速定位时间范围内的消息。

---

### 2. idx_next_run (scheduled_tasks 表)

```sql
CREATE INDEX IF NOT EXISTS idx_next_run ON scheduled_tasks(next_run);
```

**优化场景**:
- `getDueTasks()` - 查询 next_run <= now 的任务

**性能提升**: 快速找到所有到期任务，无需扫描整个表。

---

### 3. idx_status (scheduled_tasks 表)

```sql
CREATE INDEX IF NOT EXISTS idx_status ON scheduled_tasks(status);
```

**优化场景**:
- `getDueTasks()` - 筛选 status = 'active' 的任务
- `getAllTasks()` - 可能按状态筛选任务

**性能提升**: 快速过滤活跃任务，减少扫描行数。

---

### 4. idx_task_run_logs (task_run_logs 表)

```sql
CREATE INDEX IF NOT EXISTS idx_task_run_logs ON task_run_logs(task_id, run_at);
```

**优化场景**:
- `getTaskRunLogs()` - 查询指定任务的执行日志

**性能提升**:
- 复合索引支持按 task_id 和 run_at 的组合查询
- 覆盖索引（包含查询所需的所有字段），避免回表查询

---

## 设计亮点

### 1. 渐进式数据库迁移

通过 `try-catch` 包裹 `ALTER TABLE` 语句，实现向后兼容的数据库升级：

```typescript
try {
  db.exec(`ALTER TABLE messages ADD COLUMN sender_name TEXT`);
} catch { /* column already exists */ }
```

### 2. 机器人消息过滤

通过内容前缀而非 `is_from_me` 字段过滤机器人消息，因为用户和机器人共享 WhatsApp 账户：

```typescript
WHERE content NOT LIKE ?
// 参数: `${botPrefix}:%`
```

### 3. 时间戳更新策略

使用 `MAX()` 函数确保时间戳始终为最新值：

```typescript
ON CONFLICT(jid) DO UPDATE SET
  last_message_time = MAX(last_message_time, excluded.last_message_time)
```

### 4. 动态 SQL 构建

`updateTask()` 函数动态构建 UPDATE 语句，仅更新提供的字段：

```typescript
const fields: string[] = [];
if (updates.prompt !== undefined) { fields.push('prompt = ?'); values.push(updates.prompt); }
// ...
db.prepare(`UPDATE scheduled_tasks SET ${fields.join(', ')} WHERE id = ?`).run(...values);
```

### 5. 外键约束和级联删除

虽然 SQLite 支持外键约束，但 `deleteTask()` 手动删除子记录以确保顺序正确：

```typescript
db.prepare('DELETE FROM task_run_logs WHERE task_id = ?').run(id);
db.prepare('DELETE FROM scheduled_tasks WHERE id = ?').run(id);
```

---

## 总结

`src/db.ts` 是一个设计精良的数据持久化层，具有以下特点：

1. **清晰的表结构**: 4 个表各司其职，职责明确
2. **完善的索引策略**: 针对高频查询场景优化性能
3. **渐进式迁移**: 支持数据库版本升级，向后兼容
4. **类型安全**: 充分利用 TypeScript 类型系统
5. **简洁的 API**: 每个函数职责单一，易于理解和维护

该模块为 NanoClaw 提供了可靠的数据存储基础，支持聊天元数据管理、消息历史查询和定时任务调度等核心功能。
