# 扩展与集成指南

本文档说明如何扩展 NanoClaw 的功能，包括添加新通道、集成 MCP 服务器、贡献 Skills 等。

## 核心哲学：Fork, Don't PR

**NanoClaw 的扩展方式与其他项目不同。**

大多数项目鼓励通过 Pull Request 贡献新功能。NanoClaw 采用相反的方式：

### 传统项目 vs NanoClaw

| 方式 | 传统项目 | NanoClaw |
|------|----------|----------|
| 新功能 | PR 提交到主分支 | Fork 仓库，本地修改 |
| 特性支持 | 配置开关选项 | 直接修改代码 |
| 贡献方式 | 功能 PR | Skills 脚本 |
| 代码结果 | 复杂抽象层 | 简洁直接 |

### 为什么 Fork 哲学？

1. **保持代码库简洁** - 每个用户只保留自己需要的代码
2. **避免配置地狱** - 不需要复杂的配置文件来开关各种功能
3. **真正的定制化** - 你的代码完全匹配你的需求
4. **安全审查更容易** - 小型代码库更容易理解所有代码在做什么

### 实际示例

**不要这样做：**
```
PR: "Add Telegram support alongside WhatsApp"
→ src/
  ├── whatsapp.ts      (原来的 WhatsApp)
  ├── telegram.ts      (新加的 Telegram)
  └── router.ts         (复杂的路由逻辑选择通道)
→ 配置文件增加: CHANNEL_TYPE=[whatsapp|telegram|both]
```

**这样做：**
```
Fork 仓库
用户运行: /add-telegram
Skill 直接替换 whatsapp.ts 为 telegram.ts
→ src/
  └── telegram.ts      (只有你需要的功能)
→ 无配置文件
```

---

## Skills 系统详解

### 什么是 Skills？

Skills 是 Claude Code 的扩展机制，本质上是可重用的提示词和指令。每个 Skill 是一个 `SKILL.md` 文件，描述如何执行特定任务。

### NanoClaw 中的 Skills

NanoClaw 使用 Skills 来实现所有扩展功能：

```
.claude/skills/
├── setup/              # 初始化安装
├── customize/          # 通用定制
├── add-gmail/          # Gmail 集成
├── add-parallel/       # 添加并行通道
├── convert-to-docker/  # 转换为 Docker
└── debug/              # 调试工具
```

### Skill 文件结构

```markdown
---
name: skill-name
description: 一句话描述这个技能的用途
---

# Skill 标题

详细说明和步骤...

## 第一步

描述性的步骤说明。

## 第二步

命令、代码、问题提示等...
```

### Skills 如何工作

1. **触发** - 用户在 Claude Code 中运行 `/skill-name`
2. **加载** - Claude Code 读取 `SKILL.md`
3. **执行** - Claude 遵循 Skill 中的指令执行任务
4. **完成** - 技能完成，用户的代码已修改

### 创建新的 Skill

#### 步骤 1：创建目录

```bash
mkdir -p .claude/skills/add-telegram
```

#### 步骤 2：编写 SKILL.md

```markdown
---
name: add-telegram
description: Add Telegram as the messaging channel for NanoClaw, replacing WhatsApp entirely.
---

# Add Telegram Channel

This skill replaces WhatsApp with Telegram as the primary messaging channel.

## Step 1: Install Telegram Bot API

```bash
npm install node-telegram-bot-api
```

## Step 2: Get Telegram Bot Token

Tell the user:
> 1. Start a chat with @BotFather on Telegram
> 2. Send /newbot
> 3. Follow the prompts to create a bot
> 4. Copy the API token
>
> Paste the token when ready.

Wait for user to provide the token.

## Step 3: Update .env

Add the token to .env:

```bash
echo "TELEGRAM_BOT_TOKEN=YOUR_TOKEN_HERE" >> .env
```

## Step 4: Replace Channel Implementation

Read src/index.ts and replace the WhatsApp connection code with Telegram:

```typescript
// Replace import
import TelegramBot from 'node-telegram-bot-api';

// Replace connection function
const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN!, { polling: true });

bot.on('message', async (msg) => {
  // Process message...
});
```

... (继续其余步骤)
```

#### 步骤 3：测试 Skill

```bash
# 在 Claude Code 中
claude
/add-telegram
```

---

## 添加新通道

### 通道类型

NanoClaw 支持多种通道类型：

| 类型 | 例子 | 用途 |
|------|------|------|
| **主通道** | WhatsApp self-chat, Telegram DM | 管理员控制，全局操作 |
| **输入通道** | WhatsApp groups, Slack channels | 与 assistant 对话 |
| **输出通道** | Email, SMS | 接收通知和报告 |

### 添加 Telegram 通道

#### 步骤 1：安装依赖

```bash
npm install node-telegram-bot-api
```

#### 步骤 2：修改 `src/index.ts`

**添加 Telegram 连接：**

```typescript
import TelegramBot from 'node-telegram-bot-api';

// 在文件顶部添加配置
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
```

**替换 WhatsApp 连接逻辑：**

```typescript
// 替换 connectWhatsApp 函数
async function connectTelegram(): Promise<void> {
  if (!TELEGRAM_BOT_TOKEN) {
    throw new Error('TELEGRAM_BOT_TOKEN not set in .env');
  }

  const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

  logger.info('Telegram bot connected');

  bot.on('message', async (msg) => {
    const chatId = msg.chat.id.toString();
    const text = msg.text || '';

    logger.info({ chatId, text: text.substring(0, 50) }, 'Received message');

    await processMessage(chatId, text);
  });
}
```

#### 步骤 3：修改消息存储

更新 `src/db.ts` 以适配 Telegram 的数据格式：

```typescript
// Telegram 使用数字 chat_id，需要转为字符串
export function saveMessage(chatJid: string, senderId: string, content: string): void {
  const stmt = db.prepare(`
    INSERT INTO messages (chat_jid, sender_jid, content, timestamp)
    VALUES (?, ?, ?, ?)
  `);
  stmt.run(chatJid, senderId, content, new Date().toISOString());
}
```

#### 步骤 4：发送回复

```typescript
// 添加发送函数
async function sendTelegramResponse(chatId: string, response: string): Promise<void> {
  const bot = new TelegramBot(TELEGRAM_BOT_TOKEN!, { polling: true });

  await bot.sendMessage(chatId, response);
}
```

#### 步骤 5：更新 `.env`

```bash
TELEGRAM_BOT_TOKEN=your_bot_token_here
```

### 添加 Slack 通道

#### 步骤 1：安装依赖

```bash
npm install @slack/web-api @slack/bolt
```

#### 步骤 2：创建 Slack 应用

1. 访问 https://api.slack.com/apps
2. 创建新应用
3. 启用 Socket Mode
4. 获取 Bot Token 和 App-Level Token

#### 步骤 3：修改 `src/index.ts`

```typescript
import { App } from '@slack/bolt';

const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  appToken: process.env.SLACK_APP_TOKEN,
  socketMode: true,
});

async function connectSlack(): Promise<void> {
  app.message(async ({ message, say }) => {
    const channelId = message.channel;
    const text = (message as any).text || '';

    await processMessage(channelId, text);
  });

  await app.start();
  logger.info('Slack bot connected');
}
```

#### 步骤 4：更新 `.env`

```bash
SLACK_BOT_TOKEN=xoxb-your-token
SLACK_APP_TOKEN=xapp-your-token
```

### 添加多个通道（并行模式）

NanoClaw 支持同时运行多个通道，通过 `add-parallel` skill 实现。

#### 并行通道架构

```
                     ┌─────────────┐
                     │  Main Router │
                     └──────┬──────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
   ┌────▼────┐        ┌────▼────┐        ┌────▼────┐
   │WhatsApp  │        │Telegram  │        │  Slack  │
   └────┬────┘        └────┬────┘        └────┬────┘
        │                   │                   │
        └───────────────────┴───────────────────┘
                            │
                     ┌──────▼──────┐
                     │  Agent SDK   │
                     └─────────────┘
```

#### 实现并行通道

1. **每个通道独立监听**
2. **统一消息格式**
3. **共享 session 存储**
4. **独立的响应发送**

参考 `add-parallel` skill 的实现。

---

## 添加 MCP 服务器

### 什么是 MCP？

MCP (Model Context Protocol) 是 Anthropic 的协议，用于为 AI 助手提供外部工具和能力。NanoClaw 使用 MCP 来扩展 agent 的能力。

### NanoClaw 中的 MCP 集成

#### MCP 服务器配置位置

MCP 配置在容器内的 `agent-runner/src/index.ts`：

```typescript
mcpServers: {
  nanoclaw: ipcMcp,              // NanoClaw 内部工具
  gmail: {                        // Gmail 集成
    command: 'npx',
    args: ['-y', '@gongrzhe/server-gmail-autoauth-mcp']
  },
  // 添加更多 MCP...
},
allowedTools: [
  'Bash',
  'Read', 'Write', 'Edit',
  'mcp__nanoclaw__*',            // NanoClaw 工具
  'mcp__gmail__*',               // Gmail 工具
  // 添加更多工具...
],
```

### 添加新的 MCP 服务器

#### 步骤 1：选择 MCP 服务器

搜索可用的 MCP 服务器：

- GitHub: `mcp-server`
- NPM: `@anthropic-ai/*mcp*`
- 社区维护的 MCP 列表

#### 步骤 2：更新容器配置

编辑 `container/agent-runner/src/index.ts`：

```typescript
mcpServers: {
  nanoclaw: ipcMcp,
  // 添加新的 MCP
  notion: {
    command: 'npx',
    args: ['-y', 'notion-mcp-server']
  },
  // 或者本地运行的 MCP
  local-tool: {
    command: '/path/to/local-mcp'
  }
},
allowedTools: [
  // ... 现有工具
  'mcp__notion__*',
  'mcp__local-tool__*',
],
```

#### 步骤 3：挂载必要文件

如果 MCP 需要访问配置文件，在 `src/container-runner.ts` 中添加挂载：

```typescript
const buildVolumeMounts = (groupDir: string, group: RegisteredGroup): VolumeMount[] => {
  const mounts: VolumeMount[] = [
    // ... 现有挂载
  ];

  // 添加 MCP 配置
  const notionDir = path.join(homeDir, '.notion-mcp');
  if (fs.existsSync(notionDir)) {
    mounts.push({
      hostPath: notionDir,
      containerPath: '/home/node/.notion-mcp',
      readonly: false
    });
  }

  return mounts;
};
```

#### 步骤 4：更新内存文档

编辑 `groups/CLAUDE.md`：

```markdown

## Notion Integration

You have access to Notion via MCP tools:
- `mcp__notion__search_pages` - Search pages
- `mcp__notion__get_page` - Get page content
- `mcp__notion__update_page` - Update page content

Example: "Find pages about project X" or "Update the meeting notes page"
```

#### 步骤 5：重建容器

```bash
cd container && ./build.sh
```

### 常用 MCP 服务器

| MCP | 功能 | 安装方式 |
|-----|------|----------|
| Gmail | 邮件读写 | `npx @gongrzhe/server-gmail-autoauth-mcp` |
| filesystem | 文件系统操作 | 内置 |
| GitHub | GitHub API | `npx mcp-server-github` |
| Notion | Notion 数据库 | `npx notion-mcp-server` |
| Brave Search | 搜索 | `npx @modelcontextprotocol/server-brave-search` |
| Puppeteer | 浏览器自动化 | `npx @modelcontextprotocol/server-puppeteer` |

### 创建自定义 MCP 服务器

#### 基础模板

```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const server = new Server({
  name: 'custom-mcp',
  version: '1.0.0',
}, {
  capabilities: {
    tools: {},
  },
});

// 定义工具
server.setRequestHandler('tools/list', async () => ({
  tools: [
    {
      name: 'my_custom_tool',
      description: 'Does something useful',
      inputSchema: {
        type: 'object',
        properties: {
          param1: { type: 'string', description: 'First parameter' },
        },
        required: ['param1'],
      },
    },
  ],
}));

// 处理工具调用
server.setRequestHandler('tools/call', async (request) => {
  if (request.params.name === 'my_custom_tool') {
    const { param1 } = request.params.arguments as { param1: string };
    // 实现逻辑
    return {
      content: [{ type: 'text', text: `Result: ${param1}` }],
    };
  }
  throw new Error('Unknown tool');
});

// 启动服务器
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main();
```

---

## 自定义扩展代码模板

### 1. 添加新的命令处理器

在 `src/index.ts` 中添加：

```typescript
// 在 processMessage 函数开始处添加
if (text.startsWith('/custom-command')) {
  await handleCustomCommand(chatJid, text);
  return;
}

async function handleCustomCommand(chatJid: string, command: string): Promise<void> {
  // 解析参数
  const args = command.substring('/custom-command'.length).trim();

  // 执行逻辑
  const result = await executeCustomLogic(args);

  // 发送回复
  await sendMessage(chatJid, result);
}
```

### 2. 添加新的数据库表

在 `src/db.ts` 中添加：

```typescript
export function initCustomTable(): void {
  db.exec(`
    CREATE TABLE IF NOT EXISTS custom_data (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      key TEXT UNIQUE NOT NULL,
      value TEXT NOT NULL,
      updated_at TEXT NOT NULL
    )
  `);
}

export function getCustomData(key: string): string | undefined {
  const row = db.prepare('SELECT value FROM custom_data WHERE key = ?').get(key);
  return row ? (row as any).value : undefined;
}

export function setCustomData(key: string, value: string): void {
  db.prepare(`
    INSERT OR REPLACE INTO custom_data (key, value, updated_at)
    VALUES (?, ?, ?)
  `).run(key, value, new Date().toISOString());
}
```

在 `initDatabase()` 函数中调用 `initCustomTable()`。

### 3. 添加新的调度任务类型

在 `src/task-scheduler.ts` 中添加：

```typescript
// 在 TaskConfig 接口中添加新类型
export interface CustomTaskConfig extends BaseTaskConfig {
  type: 'custom_task';
  customParam: string;
}

// 添加处理函数
async function handleCustomTask(task: CustomTaskConfig): Promise<void> {
  logger.info({ taskId: task.id }, 'Executing custom task');

  // 自定义逻辑
  const result = await runCustomTaskLogic(task.customParam);

  // 可选：发送通知
  if (task.notifyGroup) {
    await sendMessage(task.group, `Task completed: ${result}`);
  }
}
```

### 4. 添加新的容器工具（通过 IPC）

在 `container/agent-runner/src/ipc-mcp.ts` 中添加：

```typescript
// 添加到 MCP 工具列表
{
  name: 'custom_ipc_tool',
  description: 'Custom tool that runs on host',
  inputSchema: {
    type: 'object',
    properties: {
      action: { type: 'string', description: 'Action to perform' },
      data: { type: 'string', description: 'Data for the action' }
    },
    required: ['action', 'data'],
  }
}

// 添加处理逻辑
case 'custom_ipc_tool':
  const { action, data } = params as { action: string; data: string };
  const ipcResult = await processCustomIpcAction(action, data);
  return { content: [{ type: 'text', text: JSON.stringify(ipcResult) }] };
```

在 `src/index.ts` 的 IPC 处理器中添加对应逻辑：

```typescript
// 在 processTaskIpc 函数中
case 'custom_ipc_tool':
  const { action, data } = toolInput as { action: string; data: string };
  result = await handleCustomAction(action, data);
  break;

async function handleCustomAction(action: string, data: string): Promise<any> {
  // 实现主机端逻辑
  logger.info({ action, data }, 'Custom IPC action');

  // 返回结果
  return { success: true, output: 'Action completed' };
}
```

### 5. 添加新的挂载点

在 `src/container-runner.ts` 中修改 `buildVolumeMounts`：

```typescript
// 添加自定义挂载目录
const customDataDir = path.join(homeDir, '.nanoclaw-data');
if (fs.existsSync(customDataDir)) {
  mounts.push({
    hostPath: customDataDir,
    containerPath: '/home/node/.nanoclaw-data',
    readonly: false,
  });
}

// 支持每个组的自定义挂载
if (group.containerConfig?.additionalMounts) {
  for (const mount of group.containerConfig.additionalMounts) {
    mounts.push({
      hostPath: expandPath(mount.hostPath),
      containerPath: mount.containerPath,
      readonly: mount.readonly ?? true,
    });
  }
}
```

在 `data/registered_groups.json` 中添加配置：

```json
{
  "JID": {
    "name": "group-name",
    "folder": "folder",
    "trigger": "@Trigger",
    "added_at": "2024-01-01T00:00:00Z",
    "containerConfig": {
      "additionalMounts": [
        {
          "hostPath": "~/projects/my-app",
          "containerPath": "my-app",
          "readonly": false
        }
      ]
    }
  }
}
```

### 6. 添加新的日志级别或格式

在 `src/index.ts` 中修改 logger 配置：

```typescript
const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  formatters: {
    level: (label) => {
      return { level: label.toUpperCase() };
    },
  },
  timestamp: pino.stdTimeFunctions.isoTime,
  transport: process.env.NODE_ENV === 'development'
    ? {
        target: 'pino-pretty',
        options: {
          colorize: true,
          translateTime: 'SYS:standard',
          ignore: 'pid,hostname',
        },
      }
    : undefined,
});
```

---

## 贡献 Skills 到社区

### Skill 贡献流程

1. **创建 Skill** - 在 `.claude/skills/your-skill/` 中创建 `SKILL.md`
2. **本地测试** - 确保 Skill 在你的环境中正常工作
3. **提交 PR** - 向 NanoClaw 仓库提交 PR

### Skill 最佳实践

#### 文件命名

- 使用 kebab-case: `add-telegram`, `setup-linux`, `convert-to-docker`
- 描述性: `add-gmail` 而不是 `email`
- 以动词开头: `add`, `setup`, `convert`, `enable`

#### 文件内容

```markdown
---
name: skill-name
description: 单行简短描述（最多 80 字符）
---

# 技能标题

简短介绍（1-2 段落）

## 使用场景

何时使用此技能：
- 情况 1
- 情况 2

## 前置要求

列出必要的条件：
- 依赖项
- 账户/密钥
- 配置

## 步骤

### 第一步

清晰的说明。

**代码块：**
```bash
command here
```

### 第二步

继续步骤...

## 测试

告诉用户如何验证：
```bash
# 验证命令
verify-command
```

## 故障排除

常见问题和解决方案。

## 卸载

如何移除此技能的更改。
```

#### 代码质量

- 使用完整的命令路径
- 添加错误检查
- 提供回滚选项
- 说明潜在的副作用

### Skills 贡献示例

参考现有的 Skills：

- `.claude/skills/setup/SKILL.md` - 安装流程
- `.claude/skills/add-gmail/SKILL.md` - 复杂集成
- `.claude/skills/convert-to-docker/SKILL.md` - 平台迁移

---

## 完整示例：添加 Discord 通道

下面是一个完整的示例，展示如何添加 Discord 作为新通道。

### 步骤 1：创建 Discord 应用

1. 访问 https://discord.com/developers/applications
2. 创建新应用
3. 在 Bot 选项卡创建 Bot
4. 复制 Bot Token
5. 在 OAuth2 > URL Generator 配置权限：
   - bot: Send Messages, Read Message History
6. 使用生成的 URL 邀请 Bot 到服务器

### 步骤 2：创建 Skill 文件

```bash
mkdir -p .claude/skills/add-discord
```

`.claude/skills/add-discord/SKILL.md`:

```markdown
---
name: add-discord
description: Add Discord as a messaging channel for NanoClaw.
---

# Add Discord Channel

This skill adds Discord as an input/output channel for NanoClaw.

## Prerequisites

Before proceeding, ensure you have:
1. A Discord Bot Token
2. Bot invited to your Discord server

## Step 1: Install Dependencies

```bash
npm install discord.js
```

## Step 2: Configure Token

Ask the user:
> Paste your Discord Bot Token:

After user provides the token, add it to .env:

```bash
echo "DISCORD_BOT_TOKEN=USER_TOKEN_HERE" >> .env
```

## Step 3: Update Types

Read `src/types.ts` and add Discord-specific types:

```typescript
export interface DiscordMessage {
  id: string;
  channelId: string;
  guildId?: string;
  author: {
    id: string;
    username: string;
    discriminator: string;
  };
  content: string;
  timestamp: string;
}
```

## Step 4: Modify Index.ts

### Add Discord imports:

```typescript
import { Client, GatewayIntentBits } from 'discord.js';
import type { DiscordMessage } from './types.js';
```

### Add Discord configuration:

```typescript
const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
```

### Add Discord client:

```typescript
let discordClient: Client | null = null;

async function connectDiscord(): Promise<void> {
  if (!DISCORD_BOT_TOKEN) {
    logger.warn('Discord not configured (no token)');
    return;
  }

  discordClient = new Client({
    intents: [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.MessageContent,
    ],
  });

  discordClient.on('ready', () => {
    logger.info(`Discord logged in as ${discordClient!.user.tag}`);
  });

  discordClient.on('messageCreate', async (message) => {
    // Ignore bot messages
    if (message.author.bot) return;

    // Ignore messages without trigger
    const content = message.content;
    if (!content.toLowerCase().startsWith(ASSISTANT_NAME.toLowerCase())) {
      return;
    }

    // Extract the actual message (remove trigger)
    const messageContent = content.substring(ASSISTANT_NAME.length).trim();

    // Store and process
    const discordMsg: DiscordMessage = {
      id: message.id,
      channelId: message.channel.id,
      guildId: message.guildId,
      author: {
        id: message.author.id,
        username: message.author.username,
        discriminator: message.author.discriminator,
      },
      content: messageContent,
      timestamp: message.createdAt.toISOString(),
    };

    // Convert Discord channel to NanoClaw chat format
    const chatJid = `discord:${message.channel.id}`;
    const senderId = `discord:${message.author.id}`;

    // Save to database
    saveMessage(chatJid, senderId, discordMsg.content);

    // Process the message
    await processMessage(chatJid, discordMsg.content);
  });

  await discordClient.login(DISCORD_BOT_TOKEN);
}
```

### Update message processing:

In the `processMessage` function, add Discord response sending:

```typescript
// After getting the response
if (chatJid.startsWith('discord:')) {
  await sendDiscordResponse(chatJid, response);
} else {
  // Original WhatsApp sending
  await sendMessage(chatJid, response);
}
```

### Add Discord response function:

```typescript
async function sendDiscordResponse(chatJid: string, response: string): Promise<void> {
  if (!discordClient) {
    logger.error('Discord client not initialized');
    return;
  }

  const channelId = chatJid.replace('discord:', '');

  try {
    const channel = await discordClient.channels.fetch(channelId);
    if (!channel || !('send' in channel)) {
      logger.error({ channelId }, 'Invalid Discord channel');
      return;
    }

    await channel.send(response);
    logger.info({ channelId, length: response.length }, 'Sent Discord response');
  } catch (err) {
    logger.error({ err, channelId }, 'Failed to send Discord message');
  }
}
```

### Update main initialization:

Find where `connectWhatsApp` is called and add Discord connection:

```typescript
// In main()
await connectWhatsApp();
await connectDiscord();  // Add this
```

## Step 5: Update Database

Add Discord-specific tracking in `src/db.ts`:

```typescript
export function getDiscordMessageHistory(channelId: string, limit: number = 10): any[] {
  const rows = db.prepare(`
    SELECT * FROM messages
    WHERE chat_jid = ?
    ORDER BY timestamp DESC
    LIMIT ?
  `).all(`discord:${channelId}`, limit);
  return rows;
}
```

## Step 6: Rebuild and Test

```bash
npm run build
launchctl unload ~/Library/LaunchAgents/com.nanoclaw.plist
launchctl load ~/Library/LaunchAgents/com.nanoclaw.plist
```

Tell the user:
> Discord integration is complete! Test it by sending `@Andy hello` in your Discord server.

Check logs:
```bash
tail -f logs/nanoclaw.log
```

## Troubleshooting

**Bot not responding:**
- Verify bot token is correct
- Check bot has message permissions
- Ensure bot is in the server

**Messages not being processed:**
- Check trigger word matches exactly
- Verify Message Content Intent is enabled
- Check logs for errors

## Uninstall

To remove Discord integration:

1. Remove from `.env`:
   ```bash
   sed -i '' '/DISCORD_BOT_TOKEN/d' .env
   ```

2. Remove imports and Discord code from `src/index.ts`

3. Rebuild:
   ```bash
   npm run build
   launchctl kickstart -k gui/$(id -u)/com.nanoclaw
   ```
```

---

## 总结

### 扩展 NanoClaw 的步骤

1. **Fork 仓库** - 这是第一步，也是最关键的一步
2. **确定需求** - 想要添加什么功能
3. **选择方式** - 修改代码还是创建 Skill
4. **实施更改** - 遵循最佳实践
5. **测试验证** - 确保一切正常工作
6. **贡献 Skill** - 如果有用，分享给社区

### 关键要点

- **不要提交功能 PR** - Fork 并自定义
- **使用 Skills** - 重用和分享扩展逻辑
- **保持简单** - 代码库应该易于理解
- **测试彻底** - 在部署前验证所有更改
- **记录变更** - 在你的 fork 中更新文档

### 相关文档

- [README.md](../README.md) - 项目概览
- [docs/REQUIREMENTS.md](../docs/REQUIREMENTS.md) - 架构决策
- [analysis/20-index.ts 源码解读.md](20-index.ts%20源码解读.md) - 主程序详解
- [analysis/21-container-runner.ts 源码解读.md](21-container-runner.ts%20源码解读.md) - 容器系统详解

### 获取帮助

- GitHub Issues: https://github.com/gavrielc/nanoclaw/issues
- Claude Code: 在项目中运行 `/customize` 获取指导
