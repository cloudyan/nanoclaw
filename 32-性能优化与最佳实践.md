# 性能优化与最佳实践

## 目录

- [性能基准数据](#性能基准数据)
- [性能特征分析](#性能特征分析)
- [优化建议](#优化建议)
- [最佳实践 Checklist](#最佳实践-checklist)
- [调试命令](#调试命令)
- [监控与指标](#监控与指标)

---

## 性能基准数据

### 核心性能参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `POLL_INTERVAL` | 2000ms (2秒) | WhatsApp消息轮询间隔 |
| `SCHEDULER_POLL_INTERVAL` | 60000ms (60秒) | 任务调度器检查间隔 |
| `IPC_POLL_INTERVAL` | 1000ms (1秒) | IPC文件系统轮询间隔 |
| `CONTAINER_TIMEOUT` | 300000ms (5分钟) | 单个容器执行超时时间 |
| `CONTAINER_MAX_OUTPUT_SIZE` | 10485760 (10MB) | 容器输出最大大小 |
| `GROUP_SYNC_INTERVAL_MS` | 86400000ms (24小时) | WhatsApp组元数据同步间隔 |

### 日志级别配置

```typescript
// src/index.ts, container-runner.ts, task-scheduler.ts
const logger = pino({
  level: process.env.LOG_LEVEL || 'info',  // trace, debug, info, warn, error, silent
  transport: { target: 'pino-pretty', options: { colorize: true } }
});
```

---

## 性能特征分析

### 1. 轮询机制

NanoClaw使用多层轮询机制来处理不同的任务：

#### WhatsApp消息轮询（2秒间隔）
- **位置**: `src/index.ts` 中的 `startMessageLoop()`
- **机制**: 每2秒从SQLite数据库查询新消息
- **优化**: 使用时间戳过滤，避免重复处理
- **语义保证**: 至少一次（at-least-once）投递——失败的消息会在下次轮询重试

```typescript
async function startMessageLoop(): Promise<void> {
  while (true) {
    try {
      const jids = Object.keys(registeredGroups);
      const { messages } = getNewMessages(jids, lastTimestamp, ASSISTANT_NAME);

      for (const msg of messages) {
        try {
          await processMessage(msg);
          // Only advance timestamp after successful processing
          lastTimestamp = msg.timestamp;
          saveState();
        } catch (err) {
          logger.error({ err, msg: msg.id }, 'Error processing message, will retry');
          // Stop processing this batch - failed message will be retried next loop
          break;
        }
      }
    } catch (err) {
      logger.error({ err }, 'Error in message loop');
    }
    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
  }
}
```

#### 任务调度器轮询（60秒间隔）
- **位置**: `src/task-scheduler.ts` 中的 `startSchedulerLoop()`
- **机制**: 每60秒检查是否有到期任务需要执行
- **特点**: 惰性调度，不需要精确时间触发

```typescript
export function startSchedulerLoop(deps: SchedulerDependencies): void {
  const loop = async () => {
    try {
      const dueTasks = getDueTasks();
      for (const task of dueTasks) {
        await runTask(currentTask, deps);
      }
    } catch (err) {
      logger.error({ err }, 'Error in scheduler loop');
    }
    setTimeout(loop, SCHEDULER_POLL_INTERVAL);
  };
  loop();
}
```

#### IPC轮询（1秒间隔）
- **位置**: `src/index.ts` 中的 `startIpcWatcher()`
- **机制**: 每1秒扫描IPC目录，处理来自容器的消息和任务请求
- **隔离**: 每个组有独立的IPC命名空间，防止跨组干扰

### 2. 容器启动性能

#### 启动开销分解

| 阶段 | 典型耗时 | 说明 |
|------|----------|------|
| 容器创建 | ~1-2秒 | Apple Container/Docker初始化 |
| 卷挂载 | ~0.5秒 | 最多5-6个卷挂载 |
| Agent启动 | ~2-5秒 | Node.js进程启动 + Claude Agent SDK初始化 |
| 首次响应 | ~5-15秒 | AI模型推理时间（取决于复杂度） |

#### 卷挂载配置

```typescript
// src/container-runner.ts - buildVolumeMounts()
function buildVolumeMounts(group: RegisteredGroup, isMain: boolean): VolumeMount[] {
  const mounts: VolumeMount[] = [];

  if (isMain) {
    // 主组挂载整个项目根目录
    mounts.push({ hostPath: projectRoot, containerPath: '/workspace/project' });
    mounts.push({ hostPath: path.join(GROUPS_DIR, group.folder), containerPath: '/workspace/group' });
  } else {
    // 其他组只挂载自己的文件夹
    mounts.push({ hostPath: path.join(GROUPS_DIR, group.folder), containerPath: '/workspace/group' });
  }

  // 每组独立的会话目录
  mounts.push({
    hostPath: path.join(DATA_DIR, 'sessions', group.folder, '.claude'),
    containerPath: '/home/node/.claude'
  });

  // IPC目录
  mounts.push({
    hostPath: path.join(DATA_DIR, 'ipc', group.folder),
    containerPath: '/workspace/ipc'
  });

  return mounts;
}
```

### 3. 消息处理流程

```
WhatsApp消息 → Baileys事件 → SQLite存储
                                    ↓
                          startMessageLoop (每2秒)
                                    ↓
                          获取新消息 (getNewMessages)
                                    ↓
                          检查是否已注册组
                                    ↓
                          检查触发模式 (@Andy)
                                    ↓
                          准备完整上下文 (getMessagesSince)
                                    ↓
                          启动容器 (runContainerAgent)
                                    ↓
                          Claude Agent SDK处理
                                    ↓
                          返回结果 → 发送到WhatsApp
```

### 4. 资源使用特征

#### 内存使用
- **主进程**: ~50-100MB（Node.js + Baileys + SQLite）
- **每个容器**: ~150-300MB（Node.js + Claude Agent SDK）
- **峰值**: 取决于并发容器数量

#### CPU使用
- **空闲时**: <5% CPU（仅轮询）
- **消息处理时**: 10-30% CPU（单个容器）
- **并发任务**: 线性增长（每个容器独立）

#### 磁盘I/O
- **SQLite写操作**: 每条消息~1KB
- **容器日志**: 每次运行~1-100KB
- **IPC文件**: 通常<1KB（JSON载荷）

---

## 优化建议

### 1. 轮询间隔调整

#### 场景：高响应性需求
如果需要更快的消息响应，可以降低`POLL_INTERVAL`：

```typescript
// src/config.ts
export const POLL_INTERVAL = 1000; // 从2000ms降到1000ms
```

**权衡**：
- ✓ 响应延迟从2秒降至1秒
- ✗ CPU使用增加约50%
- ✗ 更多数据库查询

#### 场景：节能模式
如果运行在笔记本或需要节能：

```typescript
// src/config.ts
export const POLL_INTERVAL = 5000; // 从2000ms增加到5000ms
export const SCHEDULER_POLL_INTERVAL = 120000; // 从60秒增加到120秒
```

**权衡**：
- ✓ 显著降低CPU和电池使用
- ✗ 消息响应延迟增加至5秒

#### 场景：大量定时任务
如果使用大量定时任务，需要检查任务频率：

```typescript
// src/config.ts
export const SCHEDULER_POLL_INTERVAL = 30000; // 从60秒降到30秒
```

**权衡**：
- ✓ 定时任务精度提高（±30秒 vs ±60秒）
- ✗ 更频繁的数据库查询

### 2. 容器超时优化

#### 短任务优化
对于简单查询或快速操作，可以降低超时：

```typescript
// 为特定组配置更短的超时
const registeredGroups: Record<string, RegisteredGroup> = {
  [jid]: {
    name: 'QuickTasks',
    folder: 'quick-tasks',
    trigger: '@Andy',
    added_at: new Date().toISOString(),
    containerConfig: {
      timeout: 60000  // 1分钟超时（默认5分钟）
    }
  }
};
```

#### 复杂任务优化
对于长时间运行的分析任务：

```typescript
const registeredGroups: Record<string, RegisteredGroup> = {
  [jid]: {
    name: 'Analysis',
    folder: 'analysis',
    trigger: '@Andy',
    added_at: new Date().toISOString(),
    containerConfig: {
      timeout: 600000  // 10分钟超时
    }
  }
};
```

### 3. 日志级别优化

#### 生产环境
```bash
export LOG_LEVEL=warn
```

只记录警告和错误：
- ✓ 减少磁盘写入
- ✓ 减少I/O开销
- ✗ 调试信息缺失

#### 调试模式
```bash
export LOG_LEVEL=debug
```

记录详细调试信息：
- ✓ 便于问题诊断
- ✓ 记录容器详细输出
- ✗ 磁盘使用增加

#### 容器日志策略
```typescript
// src/container-runner.ts - 根据环境调整日志
const isVerbose = process.env.LOG_LEVEL === 'debug' || process.env.LOG_LEVEL === 'trace';

if (isVerbose) {
  // 记录完整输出（包括stdin/stdout/stderr）
  logLines.push(`=== Stderr ===`, stderr, `=== Stdout ===`, stdout);
} else {
  // 仅记录摘要
  logLines.push(`Prompt length: ${input.prompt.length} chars`);
}
```

### 4. IPC轮询优化

如果容器与主进程频繁通信，可以调整IPC轮询：

```typescript
// src/config.ts
export const IPC_POLL_INTERVAL = 500; // 从1000ms降到500ms
```

**适用场景**：
- 容器需要频繁回传数据
- 多个容器同时运行需要快速协调

### 5. 数据库优化

#### SQLite WAL模式
NanoClaw默认使用SQLite，可以通过WAL模式提高并发性能：

```typescript
// src/db.ts
// 在数据库初始化后执行
db.pragma('journal_mode = WAL');  // Write-Ahead Logging
db.pragma('synchronous = NORMAL'); // 平衡性能与安全
```

#### 定期清理
定期清理旧日志和任务运行记录：

```bash
# 清理7天前的容器日志
find groups/*/logs -name "container-*.log" -mtime +7 -delete

# 清理30天前的任务运行记录（需要实现）
# SELECT COUNT(*) FROM task_runs WHERE run_at < date('now', '-30 days');
```

---

## 最佳实践 Checklist

### 部署前检查

- [ ] **环境配置**: 根据使用场景设置适当的`LOG_LEVEL`
  - 开发环境: `debug` 或 `info`
  - 生产环境: `warn` 或 `error`

- [ ] **轮询间隔**: 根据响应需求调整`POLL_INTERVAL`
  - 即时响应: `1000ms`
  - 平衡模式: `2000ms`（默认）
  - 节能模式: `5000ms`

- [ ] **容器超时**: 为不同任务类型配置合适的超时时间
  - 简单查询: `60000ms`（1分钟）
  - 标准任务: `300000ms`（5分钟，默认）
  - 复杂分析: `600000ms`（10分钟）

- [ ] **磁盘空间**: 确保足够的磁盘空间用于日志和数据库
  - 预留至少500MB用于容器日志
  - 定期清理旧日志文件

- [ ] **监控系统**: 设置监控和告警
  - 监控容器失败率
  - 监控磁盘使用量
  - 监控内存使用

### 运维最佳实践

- [ ] **日志管理**: 实施日志轮转策略
  ```bash
  # 使用logrotate管理日志
  nano ~/nanoclaw/logrotate.conf
  # 输入logrotate配置
  sudo cp ~/nanoclaw/logrotate.conf /usr/local/etc/logrotate.d/nanoclaw
  ```

- [ ] **备份策略**: 定期备份关键数据
  - SQLite数据库: `data/nanoclaw.db`
  - 组配置: `data/registered_groups.json`
  - 会话状态: `data/sessions.json`

- [ ] **健康检查**: 实施定期健康检查
  ```bash
  # 检查NanoClaw进程
  ps aux | grep "node.*src/index.ts"

  # 检查Apple Container状态
  container system status
  ```

- [ ] **错误监控**: 重点关注以下错误
  - 容器超时（可能需要增加超时时间或优化任务）
  - WhatsApp连接失败（需要重新认证）
  - 磁盘空间不足

- [ ] **性能基线**: 建立性能基线以便发现异常
  - 正常响应时间分布
  - 容器启动时间
  - CPU/内存使用模式

### 安全最佳实践

- [ ] **环境变量保护**: 确保`.env`文件不被提交到Git
  ```bash
  # .gitignore 中包含
  .env
  .env.local
  ```

- [ ] **访问控制**: 定期审查`registered_groups.json`
  - 移除不需要的组
  - 验证additionalMounts配置

- [ ] **日志审计**: 定期审查日志文件
  ```bash
  # 查找未授权的IPC尝试
  grep "Unauthorized IPC" data/ipc/*/messages/*.json

  # 查找失败的容器启动
  grep "Container exited with error" groups/*/logs/*.log
  ```

- [ ] **敏感信息**: 确保不在日志中记录敏感内容
  - API密钥已过滤（环境变量白名单）
  - 认证令牌不被记录

### 开发最佳实践

- [ ] **错误处理**: 所有异步操作都有适当的错误处理
  ```typescript
  try {
    await operation();
  } catch (err) {
    logger.error({ err }, 'Operation failed');
    // 适当的恢复逻辑
  }
  ```

- [ ] **资源清理**: 确保定时器和文件句柄被正确清理
  ```typescript
  const timeout = setTimeout(() => { ... }, interval);
  // 在完成时清除
  clearTimeout(timeout);
  ```

- [ ] **日志一致性**: 使用统一的日志格式
  ```typescript
  logger.info({ context: data }, 'Descriptive message');
  ```

- [ ] **测试覆盖**: 确保关键逻辑有测试覆盖
  - 消息处理流程
  - 任务调度逻辑
  - IPC安全性

---

## 调试命令

### 1. 实时日志查看

```bash
# 查看主进程日志（如果输出到文件）
tail -f ~/Library/Logs/nanoclaw/output.log

# 或查看systemd/launchctl日志
log show --predicate 'process == "nanoclaw"' --style syslog --last 1h
```

### 2. 容器日志检查

```bash
# 查看最新容器日志
ls -lt groups/*/logs/container-*.log | head -1 | awk '{print $NF}'

# 查看特定组的容器日志
cat groups/main/logs/container-*.log | tail -100

# 查找失败的容器运行
grep "Container exited with error" groups/*/logs/*.log

# 查找容器超时
grep "Container timeout" groups/*/logs/*.log
```

### 3. 数据库查询

```bash
# 查看消息统计
sqlite3 data/nanoclaw.db "SELECT chat_jid, COUNT(*) as msg_count FROM messages GROUP BY chat_jid ORDER BY msg_count DESC LIMIT 10;"

# 查看最近消息
sqlite3 data/nanoclaw.db "SELECT sender_name, timestamp, content FROM messages ORDER BY timestamp DESC LIMIT 20;"

# 查看任务运行历史
sqlite3 data/nanoclaw.db "SELECT task_id, run_at, duration_ms, status FROM task_runs ORDER BY run_at DESC LIMIT 20;"

# 查看失败的任务运行
sqlite3 data/nanoclaw.db "SELECT task_id, run_at, error FROM task_runs WHERE status = 'error' ORDER BY run_at DESC LIMIT 10;"
```

### 4. 性能分析

```bash
# 查看进程资源使用
ps aux | grep -E "(node|container)" | grep -v grep

# 使用top/htop监控
htop -p $(pgrep -f "node.*src/index.ts")

# 查看容器资源使用
container ps
```

### 5. IPC调试

```bash
# 查看IPC目录结构
find data/ipc -type f | head -20

# 查看待处理的IPC消息
ls -la data/ipc/*/messages/*.json 2>/dev/null || echo "No pending IPC messages"

# 查看待处理的IPC任务
ls -la data/ipc/*/tasks/*.json 2>/dev/null || echo "No pending IPC tasks"

# 检查错误目录
ls -la data/ipc/errors/
```

### 6. 网络诊断

```bash
# 检查WhatsApp连接状态
# 通过日志查看: "Connected to WhatsApp" 或 "Connection closed"

# 检查代理配置（如果使用）
echo $HTTP_PROXY $HTTPS_PROXY $NO_PROXY

# 测试网络连接
curl -I https://web.whatsapp.com
```

### 7. 容器诊断

```bash
# 检查Apple Container状态
container system status

# 检查容器镜像
container images

# 手动运行容器进行测试
echo '{"prompt":"test","groupFolder":"main","chatJid":"test","isMain":true}' | container run -i nanoclaw-agent:latest

# 查看容器日志（如果持久化）
container logs <container_id>
```

### 8. 快速诊断脚本

创建`diagnose.sh`用于快速诊断：

```bash
#!/bin/bash
echo "=== NanoClaw 诊断报告 ==="
echo

echo "1. 进程状态:"
ps aux | grep -E "node.*index.ts|container" | grep -v grep
echo

echo "2. 最近错误日志:"
grep -i "error\|failed\|timeout" ~/Library/Logs/nanoclaw/*.log 2>/dev/null | tail -20
echo

echo "3. 数据库统计:"
sqlite3 data/nanoclaw.db "SELECT 'Messages: ' || COUNT(*) FROM messages UNION SELECT 'Chats: ' || COUNT(*) FROM chats UNION SELECT 'Tasks: ' || COUNT(*) FROM tasks;"
echo

echo "4. 待处理IPC消息:"
find data/ipc/*/messages -name "*.json" 2>/dev/null | wc -l
echo

echo "5. 磁盘使用:"
du -sh data/ groups/ 2>/dev/null
echo

echo "6. 最近容器失败:"
grep "Container exited with error" groups/*/logs/*.log 2>/dev/null | tail -5
echo

echo "=== 诊断完成 ==="
```

使用方法：
```bash
chmod +x diagnose.sh
./diagnose.sh
```

---

## 监控与指标

### 关键指标

#### 响应时间
- **消息处理延迟**: 从消息收到到回复发送的时间
- **容器启动时间**: 从启动命令到容器可处理请求的时间
- **任务执行时间**: 定时任务从调度到完成的时间

#### 可用性
- **WhatsApp连接状态**: 在线/离线/重连中
- **容器成功率**: 容器执行成功/失败的比率
- **IPC处理成功率**: IPC请求成功/失败的比率

#### 资源使用
- **CPU使用率**: 主进程和容器进程的CPU占用
- **内存使用率**: 各进程的内存占用
- **磁盘使用率**: 日志和数据库的增长速度

### 监控实现

#### 简单的Prometheus指标导出（可选）

可以添加Prometheus指标端点进行监控：

```typescript
// src/metrics.ts (可选扩展)
import { Registry, Counter, Histogram, Gauge } from 'prom-client';

const register = new Registry();

// 消息处理指标
export const messageCounter = new Counter({
  name: 'nanoclaw_messages_total',
  help: 'Total number of messages processed',
  registers: [register]
});

export const messageDuration = new Histogram({
  name: 'nanoclaw_message_duration_seconds',
  help: 'Message processing duration',
  buckets: [0.5, 1, 2, 5, 10, 30],
  registers: [register]
});

// 容器指标
export const containerCounter = new Counter({
  name: 'nanoclaw_containers_total',
  help: 'Total number of containers started',
  labelNames: ['group', 'status'],
  registers: [register]
});

export const containerDuration = new Histogram({
  name: 'nanoclaw_container_duration_seconds',
  help: 'Container execution duration',
  buckets: [1, 5, 10, 30, 60, 300],
  registers: [register]
});

// 导出指标
export function getMetrics() {
  return register.metrics();
}
```

---

## 总结

NanoClaw的设计哲学是**简单高效**，性能优化应该遵循以下原则：

1. **先测量，后优化** - 使用调试命令了解实际性能特征
2. **针对场景调整** - 根据实际使用场景调整轮询间隔和超时时间
3. **保持简单** - 不要过度优化，优先考虑可维护性
4. **监控关键指标** - 建立基线，及时发现异常
5. **日志策略** - 根据环境选择合适的日志级别

通过合理配置轮询间隔、容器超时和日志级别，NanoClaw可以在保持简洁的同时满足各种使用场景的性能需求。
